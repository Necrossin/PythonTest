# Python Tasks

## [№1](https://github.com/Necrossin/PythonTest/tree/main/Task1)
> На языке Python написать алгоритм (функцию) определения четности целого числа, который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути. Объяснить плюсы и минусы обеих реализаций.

Пример из условия:
```Python
def isEven(value):
    return value % 2 == 0
```

В качестве альтернативы, которая не использует проверку остатка от деления *%* (например *divmod* или *math.fmod*) или побитовые операции (*value & 1*), написаны 2 варианта функции которые проверяют последнюю цифру в заданном целом числе:

Вариант №1
```Python
even_numbers = {repr(i):True for i in range(0,9,2)}
def isEvenDict(value):
    last_num = repr(value)[-1]

    try:
        return even_numbers[last_num]
    except:
        return False
```
Если условие задачи не запрещает использовать дополнительные переменные вне самой функции, то можно использовать такой вариант.

В нём мы создаем словарь снаружи тела функции с текстом четных цифр от 0 до 8 *{"0": True, "2": True, ...}*, преобразуем проверяемое число в текст и проверяем наличие последней цифры в нашем словаре. 

Вариант №2
```Python
def isEvenSet(value):
    last_num = repr(value)[-1]
    
    return last_num in {repr(i) for i in range(0,9,2)}
```
Этот вариант подходит, если условие задачи требует, чтобы мы предоставили функцию и только её.<br/>Вариант аналогичен первому, но вместо словаря мы создаем множество четных чисел от 0 до 8 в виде текста и сразу же проверяем если последняя цифра проверяемого числа принадлежит данному множеству.

- По результатам сравнения (1000000 вызовов каждой функции) получилось, что вариант **isEven** является самым быстрым скорости выполнения.
- Вариант **isEvenDict** оказался примерно в **3.5** раза медленее чем **isEven**, в основном из-за того что нам нужно перевести число в текст и найти его последний элемент.
- Вариант **isEvenSet** оказался примерно в **12** раз медленее чем **isEven**. Это включает в себя проблемы производительности из **isEvenDict**, но при этом добавляется создание и заполнение множества при каждом вызове функции.

По итогу для быстрого определения четности целого лучше использовать пример из условия **isEven**.<br/>Являются ли предложенные варианты рабочей альтернативой? Да, но производительность из-за их специфичности явно оставляет желать лучшего.

## [№2](https://github.com/Necrossin/PythonTest/tree/main/Task2)
> На языке Python написать минимум по 2 класса реализовывающих циклический буфер FIFO. Объяснить плюсы и минусы каждой реализации.

Класс **FIFOList** - реализован с помощью списка и использованием стандартных функций *insert(0,item)* (с предварительной проверкой заполненности списка) для добавления элементов и *pop()*.

Класс **FIFODeque** - реализован с помощью двусторонней очереди *deque*. Реализация методов класса выполнена аналогично FIFOList, разве что уже нет необходимости проверять заполнен ли буфер или нет (добавление в deque автоматически убирает крайний элемент, если у него выставлен фиксированный размер).

Результары сравнения скорости работы функций обоих классов показали, что у класса **FIFODeque** есть преимущество в скорости заполнения, тогда как оба класса тратят примерно одинаковое время для вывода элементов из буфера.

Это связано с тем, что в **FIFODeque** для заполнения используется *appendleft(item)* (с постоянной сложностью O(1)), но для вывода используется *pop()* (как и в **FIFOList**).

## [№3](https://github.com/Necrossin/PythonTest/tree/main/Task3)
> На языке Python предложить алгоритм, который быстрее всего (по процессорным тикам) отсортирует данный ей массив чисел. Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным). Объяснить, почему вы считаете, что функция соответствует заданным критериям.

Выбирая между алгоритмами **Merge sort** и **Quick sort**, всё-таки хочется отметить последний. Он так же как и **Merge sort** использует принцип деления массива на части с перераспределением элементов и повтором этих шагов пока массив не будет полностью отсортирован, но в отличие от **Merge sort** деление не всегда происходит по середине массива.

Достоинствами алгоритма является его быстродействие по сравнению с **Bubble sort/Insertion sort/Merge sort** и сложностью *O(nlogn)* (в среднем), а так же простотой и компактностью реализации.

При этом скорость алгоритма может варьироваться в худшую сторону из-за того какой будет центральная точка при делении массивов, что ведет к дополнительным шагам. Например когда массив уже отсортирован и при выполнении алгоритма центральная точка постоянно попадает на наименьшее значение, что ведет к сложности O(n^2).

Для оценки скорости было проведено сравнение алгоритмов **Quick sort**, **Merge sort** и **sorted** (который доступен по умолчанию в Python).
<br/>Каждому алгоритму было дано 3 массива разных размеров, а также их отсортированные версии.

По результатам сравнения скорости получилось, что **Quick sort** работает быстрее чем **Merge sort**, но всё-таки уступает по скорости функции **sorted**.<br/>Время выполнения алгоритма **Quick sort** на отсортированных массивах примерно в 2 раза больше, чем на не отсортированных. В то же время у алгоритма **Merge sort** наоборот: время выполнения примерно в 1.5-2 раза быстрее на отсортированных массивах, чем на неотсортированных. В итоге можно сказать, что **Quick sort** будет не самой плохой альтернативой функции **sorted**, если по каким-то причинам нет возможности ее использовать (а такие причины мне довольно сложно назвать).



